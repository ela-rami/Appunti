<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lezione 9: Heap; inserimento, cancellazione, modifica di priorità</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito+Sans:wght@300;400;600;700&family=Source+Code+Pro:wght@400;500&display=swap" rel="stylesheet">
    <!-- MathJax per rendering formule LaTeX -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- Mermaid.js per diagrammi -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <link rel="stylesheet" href="../../assets/css/common.css">

    <style>
        /* Stili specifici già presenti nelle altre lezioni, li riporto per coerenza */
        :root {
            --bg-deep-space: #111827;
            --bg-card: #1f2937;
            --bg-header: #1A202C;
            --text-primary: #e5e7eb;
            --text-secondary: #9ca3af;
            --accent-primary: #60a5fa;
            --accent-secondary: #818cf8;
            --code-bg: #2a303c;
            --code-text: #c3c9d6;
            --border-soft: rgba(107, 114, 128, 0.2);
            --shadow-soft: rgba(0, 0, 0, 0.25);
            --font-main: 'Nunito Sans', sans-serif;
            --font-code: 'Source Code Pro', monospace;
            --sidebar-width: 280px;
            --header-height: 70px;
            --border-radius-main: 12px;
            --border-radius-small: 6px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body {
            font-family: var(--font-main);
            line-height: 1.7;
            color: var(--text-primary);
            background-color: var(--bg-deep-space);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            transition: margin-left 0.3s ease-in-out;
        }

        header {
            background-color: var(--bg-header);
            color: var(--text-primary);
            padding: 0 2rem;
            height: var(--header-height);
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 10px var(--shadow-soft);
            border-bottom: 1px solid var(--border-soft);
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        header h1 { font-size: 1.6rem; font-weight: 700; margin: 0; color: var(--accent-primary); }

        .hamburger-menu {
            display: block; font-size: 2rem; color: var(--accent-secondary);
            background: none; border: none; cursor: pointer; padding: 0.5rem; margin-right: 1rem;
        }
        .hamburger-menu:hover { color: var(--text-primary); }

        #sidebar {
            background-color: var(--bg-card); color: var(--text-primary); padding: 1.5rem 1rem;
            width: var(--sidebar-width); position: fixed; top: var(--header-height); left: 0;
            height: calc(100% - var(--header-height)); overflow-y: auto;
            box-shadow: 2px 0 10px var(--shadow-soft); border-right: 1px solid var(--border-soft);
            z-index: 900; transform: translateX(0); transition: transform 0.3s ease-in-out;
        }
        #sidebar.hidden { transform: translateX(calc(-1 * var(--sidebar-width))); }
        #sidebar h2 {
            font-size: 1.25rem; margin-bottom: 1.2rem; border-bottom: 1px solid var(--border-soft);
            padding-bottom: 0.6rem; color: var(--accent-secondary); font-weight: 600;
        }
        #sidebar ul { list-style: none; }
        #sidebar ul li a {
            display: block; color: var(--text-secondary); text-decoration: none;
            padding: 0.65rem 0.5rem; transition: background-color 0.2s ease, color 0.2s ease, padding-left 0.2s ease;
            border-radius: var(--border-radius-small); font-size: 0.9rem;
        }
        #sidebar ul li a:hover, #sidebar ul li a.active-link {
            background-color: rgba(96, 165, 250, 0.1); color: var(--accent-primary); padding-left: 1rem;
        }

        main {
            flex: 1; margin-left: var(--sidebar-width); padding: 2.5rem;
            transition: margin-left 0.3s ease-in-out;
        }
        
        body.sidebar-hidden main { margin-left: 0; }

        article {
            margin-bottom: 3rem; padding: 2rem; background-color: var(--bg-card);
            border-left: 4px solid var(--accent-primary); border-radius: var(--border-radius-main);
            box-shadow: 0 5px 15px var(--shadow-soft); display: none; 
        }
        article.active-section { display: block; }

        .section-title { font-size: 1.5rem; color: var(--accent-primary); margin-bottom: 1.5rem; font-weight: 600; }
        .subsection-title { font-size: 1.3rem; color: var(--accent-secondary); margin-top: 2rem; margin-bottom: 1rem; font-weight: 600; padding-bottom: 0.3rem; border-bottom: 1px dashed var(--border-soft); }
        .subsubsection-title { font-size: 1.15rem; color: var(--text-primary); margin-top: 1.5rem; margin-bottom: 0.8rem; font-weight: 600; }


        .section-content { padding-left: 15px; border-left: 1px solid var(--border-soft); font-size: 0.95rem; }

        p, .math-notation, .mermaid-container, .array-representation { 
            margin-bottom: 1rem;
            color: var(--text-secondary);
        }
        .math-block { 
            display: block;
            text-align: center;
            margin: 1.5rem auto;
            font-size: 1.1em; 
            color: var(--text-primary); 
        }
        .mermaid-container, .array-representation { 
            background-color: var(--bg-deep-space); 
            padding: 1rem;
            border-radius: var(--border-radius-small);
            border: 1px solid var(--border-soft);
            text-align: center; 
            overflow-x: auto; 
        }
        .mermaid { 
             text-align: center; 
        }

        .array-representation table {
            margin: 0 auto; /* Centra la tabella */
            border-collapse: collapse;
            font-family: var(--font-code);
        }
        .array-representation th, .array-representation td {
            border: 1px solid var(--border-soft);
            padding: 0.5em 0.75em;
            min-width: 30px; /* Larghezza minima cella */
            text-align: center;
            color: var(--text-secondary);
        }
        .array-representation th { /* Indici */
            background-color: var(--code-bg);
            color: var(--accent-primary);
            font-weight: 600;
            font-size: 0.8em;
        }
        .array-representation td { /* Valori */
             background-color: var(--bg-card);
             color: var(--text-primary);
        }
        .array-representation td.highlight-swap {
            background-color: var(--accent-secondary) !important;
            color: var(--bg-deep-space) !important;
            font-weight: bold;
        }
        .array-representation td.highlight-max {
            border: 2px solid var(--accent-primary) !important;
            font-weight: bold;
        }
         .array-representation td.greyed-out {
            background-color: #4b5563 !important; /* Grigio più scuro per elementi "fuori heapsize" */
            color: #9ca3af !important;
            font-style: italic;
        }


        ul, ol { margin-left: 25px; margin-bottom: 1rem; color: var(--text-secondary); }
        li { margin-bottom: 0.5rem; }
        strong { font-weight: 700; color: var(--text-primary); }

        code, pre { font-family: var(--font-code); }
        code { background-color: var(--code-bg); color: var(--code-text); padding: 0.2em 0.4em; border-radius: var(--border-radius-small); font-size: 0.85em; }
        pre {
            background-color: var(--code-bg); color: var(--code-text); padding: 1.2rem;
            border-radius: var(--border-radius-small); overflow-x: auto; margin-bottom: 1.5rem;
            font-size: 0.9em; line-height: 1.6; border: 1px solid var(--border-soft);
        }
        pre code { background-color: transparent; padding: 0; font-size: inherit; color: inherit; }
        
        .note-box {
            background-color: rgba(129, 140, 248, 0.1); /* Viola chiaro trasparente */
            border-left: 4px solid var(--accent-secondary);
            padding: 1em;
            margin: 1.5em 0;
            border-radius: var(--border-radius-small);
        }
        .note-box strong { color: var(--accent-secondary); }


        footer {
            text-align: center; padding: 1.5rem; background-color: var(--bg-header);
            color: var(--text-secondary); margin-top: auto; border-top: 1px solid var(--border-soft);
        }
        
        .overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(17, 24, 39, 0.7); backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px); z-index: 950;
        }
        body.sidebar-overlay-active .overlay { display: block; }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-deep-space); }
        ::-webkit-scrollbar-thumb { background-color: var(--accent-secondary); border-radius: 10px; border: 2px solid var(--bg-deep-space); }
        ::-webkit-scrollbar-thumb:hover { background-color: var(--accent-primary); }

        @media (max-width: 992px) {
            .hamburger-menu { display: block; }
            #sidebar {
                transform: translateX(calc(-1 * var(--sidebar-width)));
                top: 0; 
                height: 100vh;
                padding-top: 1.5rem;
                z-index: 1100;
                border-right: none;
            }
            #sidebar.open { transform: translateX(0); }
            main { margin-left: 0 !important; }
        }

        @media (min-width: 993px) {
            body:not(.sidebar-hidden) main { margin-left: var(--sidebar-width); }
            body.sidebar-hidden main { margin-left: 0; }
            #sidebar { transform: translateX(0); }
            #sidebar.hidden { transform: translateX(calc(-1 * var(--sidebar-width))); }
            .overlay { display: none !important; }
        }

        @media (max-width: 768px) {
            header h1 { font-size: 1.3rem; }
            main { padding: 2rem 1rem; }
            .section-title { font-size: 1.35rem; }
            article { padding: 1.5rem; }
        }
    </style>
</head>
<body data-pdf-path="Nota 29 ott 2020 (2).pdf">
    <div class="overlay"></div>
    <header>
        <button class="hamburger-menu" id="hamburger-btn">☰</button>
        <h1>Lezione 9: Heap; inserimento, cancellazione, modifica di priorità</h1>
        <div></div>
    </header>

    <nav id="sidebar">
        <div class="sidebar-actions">
            <a href="../../ASD_home.html" class="sidebar-action-button" id="lezioni-home-btn">Torna alle Lezioni</a>
            <a href="#" class="sidebar-action-button" id="appunti-prof-btn" target="_blank" rel="noopener noreferrer">Appunti Prof (PDF)</a>
        </div>
        <h2>Indice Argomenti</h2>
        <ul>
            <li><a href="#recap-heap-insert" class="sidebar-link">1. Recap: Max-Heap-Insert</a></li>
            <li><a href="#max-heap-extract" class="sidebar-link">2. Operazione Max-Heap-Extract (Extract-Max)</a></li>
            <li><a href="#heapify-procedura" class="sidebar-link">2.1. Procedura Ausiliaria: Heapify (o Max-Heapify)</a></li>
            <li><a href="#complessita-heapify" class="sidebar-link">2.2. Complessità di Heapify</a></li>
            <li><a href="#correttezza-heapify" class="sidebar-link">2.3. Correttezza di Heapify</a></li>
            <li><a href="#esercizio-max-heap-modify" class="sidebar-link">3. Esercizio (per casa): Max-Heap-Modify-Key</a></li>
            <li><a href="#heapsort-algoritmo" class="sidebar-link">4. Algoritmo HeapSort</a></li>
            <li><a href="#build-heap-procedura" class="sidebar-link">4.1. Procedura Ausiliaria: Build-Max-Heap</a></li>
            <li><a href="#complessita-build-heap" class="sidebar-link">4.2. Complessità di Build-Max-Heap (Analisi più precisa)</a></li>
            <li><a href="#complessita-heapsort" class="sidebar-link">4.3. Complessità di HeapSort</a></li>
        </ul>
    </nav>

    <main>
        <article id="recap-heap-insert" class="content-section">
            <h2 class="section-title">1. Recap: Operazione Max-Heap-Insert</h2>
            <div class="section-content">
                <p>Nella lezione precedente abbiamo introdotto l'operazione <code>Max-Heap-Insert(H, K)</code>, che inserisce una nuova chiave <code>K</code> in una Max-Heap <code>H</code>.</p>
                <p><strong>Idea chiave:</strong></p>
                <ol>
                    <li>Si incrementa <code>H.heapsize</code>.</li>
                    <li>Si inserisce <code>K</code> nella nuova ultima posizione (foglia).</li>
                    <li>Si fa "risalire" <code>K</code> scambiandola con il genitore finché la proprietà di Max-Heap non è ristabilita o si raggiunge la radice.</li>
                </ol>
                <pre><code class="language-pseudocode">
Max-Heap-Insert(H, K)  // Costo O(1) + costo del while
  if H.heapsize < H.length then
    H.heapsize ← H.heapsize + 1
    H[H.heapsize] ← K
    
    i ← H.heapsize
    
    // Ciclo per far risalire l'elemento (Heapify-Up implicito)
    while (i > 1 AND H[PARENT(i)] < H[i]) do  // Errore corretto: H[PARENT(i)] < H[i] per Max-Heap
      SWAP(H[i], H[PARENT(i)])
      i ← PARENT(i)
  // else: gestire overflow (heap pieno)
                </code></pre>
                 <div class="note-box">
                    <strong>Attenzione (Correzione dallo pseudo-codice della lezione precedente):</strong> Per una Max-Heap, la condizione del `while` per far risalire l'elemento è <code>H[PARENT(i)] < H[i]</code> (se il genitore è più piccolo del figlio, scambio). Nell'immagine OCR della lezione 8 c'era un <code>></code>, che sarebbe stato per una Min-Heap o un errore di trascrizione. La logica corretta per Max-Heap è "se il figlio è più grande del padre, scambia per far salire il figlio".
                </div>
                <p>La complessità di questa operazione è \(O(\log n)\) perché nel caso peggiore l'elemento risale dalla foglia più profonda fino alla radice, percorrendo un cammino di lunghezza pari all'altezza dell'heap, che è \(O(\log n)\).</p>
                <div class="mermaid-container">
                    <pre class="mermaid">
                    graph TD;
                        R("Radice") --> P("Genitore (P)");
                        P --> I_new("Nuovo K (i)");
                        I_new --> LP("...eventuali figli di K...");
                        style R fill:#ddd,stroke:#333,stroke-width:2px;
                        style P fill:#ddd,stroke:#333,stroke-width:2px;
                        style I_new fill:#60a5fa,stroke:#333,stroke-width:2px;

                        subgraph "Logica di Heapify-Up"
                        direction LR
                           Start("K inserito in H[heapsize]") --> C1{"i > 1 AND H[PARENT(i)] < H[i] ?"};
                           C1 -- Vero --> SWAP["SWAP(H[i], H[PARENT(i)])"];
                           SWAP --> UPD_I["i ← PARENT(i)"];
                           UPD_I --> C1;
                           C1 -- Falso --> End("Fine");
                        end
                    </pre>
                </div>
                 <p>L'immagine della lavagna (pagina 1) mostra un albero e un array, illustrando che `m = H.heapsize` e che l'inserimento avviene "gonfiando" l'heap e poi ristabilendo la proprietà.</p>
            </div>
        </article>

        <article id="max-heap-extract" class="content-section">
            <h2 class="section-title">2. Operazione Max-Heap-Extract (Extract-Max)</h2>
            <div class="section-content">
                <p>L'operazione <code>Max-Heap-Extract(H)</code> (o semplicemente <code>Extract-Max</code>) rimuove e restituisce l'elemento con la chiave (priorità) massima dalla Max-Heap <code>H</code>.</p>
                <p><strong>Proprietà:</strong> In una Max-Heap, l'elemento con la chiave massima si trova sempre alla radice, cioè in <code>H[1]</code>.</p>
                <p><strong>Idea dell'Algoritmo:</strong></p>
                <ol>
                    <li>Se l'heap è vuoto (<code>H.heapsize < 1</code>), restituisci un errore.</li>
                    <li>Salva il valore della radice (<code>H[1]</code>), che è il massimo da restituire.</li>
                    <li>Sposta l'ultimo elemento dell'heap (quello in posizione <code>H[H.heapsize]</code>) alla radice (<code>H[1]</code>). Questo crea un "buco" alla fine dell'heap.</li>
                    <li>Decrementa la dimensione dell'heap: <code>H.heapsize ← H.heapsize - 1</code>. (Il "buco" ora è formalmente fuori dall'heap).</li>
                    <li>L'elemento spostato alla radice potrebbe violare la proprietà di Max-Heap (potrebbe essere più piccolo dei suoi nuovi figli). Bisogna ristabilire la proprietà facendo "scendere" questo elemento nella posizione corretta. Questa operazione di ripristino si chiama <strong>Heapify</strong> (o Max-Heapify).</li>
                </ol>
                <p>La professoressa illustra questo con un diagramma (pagina 1 e 2 degli appunti OCR): il massimo (100) viene scambiato con l'ultima foglia (5). Il 100 viene "tolto" (la heapsize si accorcia). Il 5 ora è alla radice e potrebbe essere "troppo piccolo".</p>
                <div class="array-representation">
                    <p>Situazione Iniziale (esempio):</p>
                    <table>
                        <thead><tr><th>Idx:</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>...</th><th>size</th></tr></thead>
                        <tbody><tr><td>Val:</td><td class="highlight-max">100</td><td>80</td><td>90</td><td>...</td><td>...</td><td>...</td><td>5</td></tr></tbody>
                    </table>
                    <p>Passo 1: Scambia H[1] con H[heapsize]</p>
                     <table>
                        <thead><tr><th>Idx:</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>...</th><th>size</th></tr></thead>
                        <tbody><tr><td>Val:</td><td class="highlight-swap">5</td><td>80</td><td>90</td><td>...</td><td>...</td><td>...</td><td class="highlight-swap">100</td></tr></tbody>
                    </table>
                    <p>Passo 2: Decrementa heapsize. Il 100 è ora "fuori" dall'heap (ma ancora nel vettore, pronto per essere restituito).</p>
                     <table>
                        <thead><tr><th>Idx:</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>...</th><th>size-1</th><th>size</th></tr></thead>
                        <tbody><tr><td>Val:</td><td class="highlight-max">5</td><td>80</td><td>90</td><td>...</td><td>...</td><td>...</td><td>...</td><td class="greyed-out">100</td></tr></tbody>
                    </table>
                    <p>Passo 3: Il 5 alla radice potrebbe violare la proprietà di Max-Heap. Si chiama Heapify(H, 1).</p>
                </div>

                <pre><code class="language-pseudocode">
Max-Heap-Extract(H) // Costo O(log n)
  if H.heapsize < 1 then
    error "Heap underflow" // Heap vuoto
  
  max_val ← H[1]
  H[1] ← H[H.heapsize] // Sposta l'ultimo elemento alla radice
  H.heapsize ← H.heapsize - 1
  
  // Ristabilisce la proprietà di Max-Heap a partire dalla radice
  Max-Heapify(H, 1) // Chiamata alla procedura ausiliaria
  
  return max_val
                </code></pre>
            </div>
        </article>

        <article id="heapify-procedura" class="content-section">
            <h3 class="subsection-title">2.1. Procedura Ausiliaria: Max-Heapify(H, i)</h3>
            <div class="section-content">
                <p>La procedura <code>Max-Heapify(H, i)</code> (spesso chiamata solo `Heapify`) è cruciale. Ha una <strong>precondizione</strong> fondamentale:</p>
                <p><strong>Precondizione per Max-Heapify(H, i):</strong> Si assume che i sottoalberi radicati nei figli di `i` (cioè <code>LEFT(i)</code> e <code>RIGHT(i)</code>) siano già delle Max-Heap. L'elemento in <code>H[i]</code> potrebbe essere più piccolo di uno dei suoi figli, violando la proprietà di Max-Heap per il nodo `i`.</p>
                <p><strong>Obiettivo di Max-Heapify(H, i):</strong> Far "scendere" (<em>float down</em>) l'elemento <code>H[i]</code> nell'albero in modo che il sottoalbero radicato in `i` diventi una Max-Heap.</p>
                <p><strong>Idea dell'Algoritmo Max-Heapify(H, i):</strong></p>
                <ol>
                    <li>Trova il più grande tra <code>H[i]</code>, <code>H[LEFT(i)]</code> (se esiste), e <code>H[RIGHT(i)]</code> (se esiste). Sia <code>m</code> l'indice di questo elemento più grande.</li>
                    <li>Se il più grande non è <code>H[i]</code> (cioè se <code>m ≠ i</code>), allora <code>H[i]</code> viola la proprietà di Max-Heap con uno dei suoi figli.
                        <ul>
                            <li>Scambia <code>H[i]</code> con <code>H[m]</code> (l'elemento più grande tra i tre).</li>
                            <li>Ora <code>H[i]</code> (il nuovo valore in posizione i) soddisfa la proprietà rispetto ai suoi figli (era il più grande). Tuttavia, l'elemento che è stato spostato in basso (l'originale <code>H[i]</code>, che ora è in <code>H[m]</code>) potrebbe violare la proprietà di Max-Heap nel sottoalbero radicato in `m`.</li>
                            <li>Richiama ricorsivamente <code>Max-Heapify(H, m)</code> per correggere il sottoalbero.</li>
                        </ul>
                    </li>
                    <li>Se il più grande è già <code>H[i]</code> (cioè <code>m = i</code>), allora il sottoalbero radicato in `i` è già una Max-Heap e non si deve fare nulla.</li>
                </ol>
                <p>La professoressa illustra (pagina 2) uno scenario: se 5 è alla radice, e i figli sono 80 e 90. Il massimo tra {5, 80, 90} è 90. Quindi 5 e 90 vengono scambiati. Ora 90 è alla radice, ma 5 è finito al posto del 90 e potrebbe essere più piccolo dei *suoi* nuovi figli. Si prosegue ricorsivamente.</p>
                <div class="mermaid-container">
                    <pre class="mermaid">
                    graph TD
                        I["H[i] (valore iniziale K)"] -- Figlio Sinistro --> L["H[LEFT(i)]"];
                        I -- Figlio Destro --> R["H[RIGHT(i)]"];

                        subgraph "Logica di Max-Heapify(H,i)"
                            S("Inizio con nodo i") --> C1{"Trova 'largest' tra i, LEFT(i), RIGHT(i)"};
                            C1 --> C2{"largest ≠ i ?"};
                            C2 -- Vero --> Swap["SWAP(H[i], H[largest])"];
                            Swap --> RecCall["Max-Heapify(H, largest)"];
                            RecCall --> E("Fine");
                            C2 -- Falso --> E;
                        end
                    </pre>
                </div>

                <pre><code class="language-pseudocode">
Max-Heapify(H, i) // Costo O(log n) o O(altezza dell'heap radicato in i)
  l ← LEFT(i)
  r ← RIGHT(i)
  
  // Determina quale tra i, l, r contiene la chiave più grande
  largest ← i 
  if l ≤ H.heapsize AND H[l] > H[i] then
    largest ← l
  // else: largest rimane i (o diventa l se H[l] > H[i])
  
  if r ≤ H.heapsize AND H[r] > H[largest] then 
    // Nota: confronto H[r] con H[largest], non con H[i] direttamente. 
    // Questo assicura che 'largest' sia l'indice del massimo dei tre.
    largest ← r
  
  // Se i non è il più grande, scambia e richiama ricorsivamente
  if largest ≠ i then
    SWAP(H[i], H[largest])
    Max-Heapify(H, largest) // Chiamata ricorsiva sul sottoalbero modificato
                </code></pre>
            </div>
        </article>

        <article id="complessita-heapify" class="content-section">
            <h3 class="subsection-title">2.2. Complessità di Max-Heapify</h3>
            <div class="section-content">
                <p>Il costo di <code>Max-Heapify(H, i)</code> dipende dall'altezza del sottoalbero radicato in `i`.</p>
                <p>Le operazioni all'interno di una singola chiamata a `Max-Heapify` (calcolo di `l` e `r`, confronti, eventuale swap) costano \(\Theta(1)\).</p>
                <p>La chiamata ricorsiva, se avviene, è su un sottoalbero la cui radice è un figlio di `i`. Nel caso peggiore, la chiamata ricorsiva scende lungo un cammino dalla radice del sottoalbero originale (nodo `i`) fino a una foglia.</p>
                <p>La lunghezza di questo cammino è al più l'altezza \(h_i\) del sottoalbero radicato in `i`.</p>
                <p>Quindi, la complessità di <code>Max-Heapify(H, i)</code> è \(O(h_i)\), dove \(h_i\) è l'altezza del nodo `i` (distanza massima da `i` a una foglia nel suo sottoalbero).</p>
                <p>Se `Max-Heapify` è chiamata sulla radice dell'intero heap (indice 1), l'altezza è l'altezza dell'heap, \(h = \Theta(\log n)\).</p>
                <p>Quindi, <code>Max-Heapify(H, 1)</code> costa \(O(\log n)\).</p>
                <p><strong>Equazione di Ricorrenza per T(h) (complessità di Heapify in funzione dell'altezza h del sottoalbero):</strong></p>
                <p>Sia \(T(h)\) il costo di `Heapify` su un nodo di altezza \(h\).</p>
                <div class="math-block">
                \( T(h) \le \begin{cases} \Theta(1) & \text{se } h=0 \text{ (foglia)} \\ \Theta(1) + T(h-1) & \text{se } h > 0 \end{cases} \)
                </div>
                <p>Questa ricorrenza si srotola in \(T(h) = \sum_{j=0}^{h} \Theta(1) = \Theta(h)\).</p>
                <p>Poiché \(h = O(\log n)\), allora \(T(n) = O(\log n)\).</p>
                <p>La professoressa disegna un albero (pagina 4 OCR) e mostra come la chiamata ricorsiva di Heapify segua un cammino. Il costo è proporzionale alla lunghezza del cammino più lungo da `i` a una foglia.
                Un'altra analisi è stata fatta considerando `n` come il numero di nodi nel sottoalbero radicato in `i`.
                Se la chiamata ricorsiva avviene, va o sul sottoalbero sinistro o su quello destro.
                Nel caso peggiore, uno dei due sottoalberi potrebbe contenere fino a \(\approx 2n/3\) dei nodi del sottoalbero corrente (questo avviene quando l'ultimo livello è pieno solo per metà circa da un lato).
                Quindi, \(T(n) \le T(2n/3) + \Theta(1)\).
                Usando il Master Theorem (Caso 2, dato che \(n^{\log_b a} = n^{\log_{3/2} 1} = n^0 = 1\), e \(f(n) = \Theta(1)\)), si ottiene \(T(n) = \Theta(\log n)\).</p>
            </div>
        </article>
        
        <article id="correttezza-heapify" class="content-section">
            <h3 class="subsection-title">2.3. Correttezza di Max-Heapify</h3>
            <div class="section-content">
                <p><strong>Teorema di Correttezza per Max-Heapify(H, i):</strong> Data una Max-Heap <code>H</code> e un indice <code>i</code>, se i sottoalberi radicati in <code>LEFT(i)</code> e <code>RIGHT(i)</code> sono Max-Heap, allora <code>Max-Heapify(H, i)</code> fa sì che il sottoalbero radicato in <code>i</code> diventi una Max-Heap.</p>
                <p><strong>Dimostrazione per Induzione (sull'altezza del nodo `i` o sul numero di chiamate ricorsive):</strong></p>
                <ul>
                    <li><strong>Caso Base (0 chiamate ricorsive):</strong>
                        Questo avviene quando `m = i` (cioè `H[i]` è già il massimo tra `H[i]`, `H[LEFT(i)]`, `H[RIGHT(i)]`).
                        In questo caso, la proprietà di Max-Heap è già soddisfatta localmente al nodo `i` rispetto ai suoi figli. Poiché per precondizione i sottoalberi figli erano già Max-Heap, l'intero sottoalbero radicato in `i` è una Max-Heap. L'algoritmo termina correttamente senza fare nulla.
                    </li>
                    <li><strong>Passo Induttivo:</strong>
                        Supponiamo che `Max-Heapify` sia corretta per tutte le chiamate ricorsive che coinvolgono al più \(k\) chiamate ricorsive (o per nodi di altezza al più \(h-1\)).
                        Vogliamo dimostrare che è corretta quando fa \(k+1\) chiamate (o per un nodo di altezza \(h\)).
                        Se `m ≠ i`, allora <code>H[i]</code> viene scambiato con <code>H[m]</code> (dove `m` è l'indice del figlio con la chiave più grande, che è anche più grande di <code>H[i]</code>).
                        Dopo lo scambio:
                        <ul>
                            <li>Il nuovo <code>H[i]</code> (che era <code>H[m]</code>) è ora il più grande tra sé stesso e i suoi figli (l'altro figlio, se esiste, era già più piccolo di <code>H[m]</code> per la precondizione sul sottoalbero di `m` o per il confronto fatto).</li>
                            <li>L'elemento originale <code>H[i]</code> è ora in <code>H[m]</code>. Questo potrebbe aver violato la proprietà di Max-Heap nel sottoalbero radicato in `m`.</li>
                            <li>Viene fatta una chiamata ricorsiva <code>Max-Heapify(H, m)</code>. Poiché il nodo `m` ha un'altezza strettamente minore di `i` (o la chiamata ricorsiva farà meno chiamate ricorsive), per ipotesi induttiva, questa chiamata a <code>Max-Heapify(H, m)</code> renderà il sottoalbero radicato in `m` una Max-Heap.</li>
                        </ul>
                        Poiché il nodo `i` ora soddisfa la proprietà di Max-Heap e i suoi sottoalberi sono stati resi Max-Heap (quello non toccato lo era già, quello toccato lo è diventato per ipotesi induttiva), l'intero sottoalbero radicato in `i` è una Max-Heap.
                    </li>
                </ul>
                <p>La professoressa illustra il passo induttivo con un diagramma (pagina 6 OCR): mostra il nodo K (ex H\[i]), i suoi figli (che sono radici di Max-Heap per precondizione). Se K è scambiato con il figlio sinistro L (che era il massimo dei tre), L va al posto di K. Ora K è al posto di L. Il sottoalbero radicato in L (ora contenente K) deve essere ripristinato con una chiamata ricorsiva, che per ipotesi induttiva funziona. Il sottoalbero destro non è stato toccato e rimane una Max-Heap. Il nuovo nodo radice (ex L) è maggiore dei suoi figli (K e il figlio destro originale).</p>
            </div>
        </article>

        <article id="esercizio-max-heap-modify" class="content-section">
            <h3 class="subsection-title">3. Esercizio (Lasciato per Casa): Max-Heap-Modify-Key(H, i, S)</h3>
            <div class="section-content">
                <p><strong>Testo del Problema (come da appunti della prof):</strong></p>
                <p>Scrivere una procedura <code>Max-Heap-Modify-Key(H, i, S)</code> che modifica la chiave dell'elemento in posizione <code>i</code> dell'heap <code>H</code> al nuovo valore <code>S</code>, e poi ripristina la proprietà di Max-Heap.</p>
                <p><strong>Nota:</strong> La nuova chiave <code>S</code> può essere sia maggiore (\(S > H[i]\)) sia minore (\(S < H[i]\)) della chiave originale. Si assume che l'indice `i` sia valido e che `H` sia una Max-Heap prima della modifica.</p>
                <p>La complessità richiesta è \(O(\log n)\).</p>

                <h4 class="subsubsection-title">Svolgimento e Spiegazione (Esercizio per Casa)</h4>
                <p>L'idea è la seguente:</p>
                <ol>
                    <li><strong>Aggiornare la chiave:</strong> Imposta <code>H[i] ← S</code>.</li>
                    <li><strong>Ripristinare la proprietà di Heap:</strong> Dopo aver cambiato la chiave in <code>H[i]</code>, la proprietà di Max-Heap potrebbe essere violata.
                        <ul>
                            <li><strong>Caso 1: La nuova chiave <code>S</code> è maggiore della chiave originale <code>H[i]</code>.</strong>
                                L'elemento <code>H[i]</code> potrebbe ora essere più grande del suo genitore. Bisogna farlo "risalire" (<em>float up</em>), simile a quanto avviene in <code>Max-Heap-Insert</code>. Si confronta <code>H[i]</code> con <code>H[PARENT(i)]</code> e si scambia se necessario, continuando a risalire.
                            </li>
                            <li><strong>Caso 2: La nuova chiave <code>S</code> è minore della chiave originale <code>H[i]</code>.</strong>
                                L'elemento <code>H[i]</code> potrebbe ora essere più piccolo di uno o entrambi i suoi figli. Bisogna farlo "scendere" (<em>float down</em>), esattamente come fa la procedura <code>Max-Heapify(H, i)</code>.
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Poiché non sappiamo a priori se la chiave è aumentata o diminuita, possiamo scrivere l'algoritmo in modo che gestisca entrambi i casi. Tuttavia, solo uno dei due percorsi (risalita o discesa) sarà effettivamente necessario.</p>

                <pre><code class="language-pseudocode">
Max-Heap-Modify-Key(H, i, S)
  if S > H[i] then // La chiave è aumentata, potrebbe dover risalire
    H[i] ← S
    // Loop per far risalire l'elemento (Heapify-Up)
    while (i > 1 AND H[PARENT(i)] < H[i]) do
      SWAP(H[i], H[PARENT(i)])
      i ← PARENT(i)
  else if S < H[i] then // La chiave è diminuita, potrebbe dover scendere
    H[i] ← S
    Max-Heapify(H, i) // Chiama la procedura standard per far scendere
  // else S == H[i], non fare nulla, l'heap è già corretto
                </code></pre>
                <p><strong>Complessità:</strong></p>
                <ul>
                    <li>Il caso \(S > H[i]\) richiede un ciclo `while` che risale l'albero, al massimo per l'altezza dell'heap: \(O(\log n)\).</li>
                    <li>Il caso \(S < H[i]\) chiama `Max-Heapify(H, i)`, che, come abbiamo visto, costa \(O(\log n)\) (o \(O(\text{altezza del nodo i})\), che è al massimo \(O(\log n)\)).</li>
                </ul>
                <p>Quindi, la complessità totale di <code>Max-Heap-Modify-Key</code> è \(O(\log n)\).</p>
            </div>
        </article>

        <article id="heapsort-algoritmo" class="content-section">
            <h2 class="section-title">4. Algoritmo di Ordinamento: HeapSort</h2>
            <div class="section-content">
                <p>Da questo capitolo in poi, HeapSort viene spiegato in modo molto più approfondito rispetto a quanto fatto dalla professoressa in quetsa lezione. La professoressa ha solo accennato al funzionamento dell'algoritmo, che approfondirà nella prossima lezione. Pertanto, è sufficiente consultare questo capitolo 4; i successivi possono essere saltati per ora.</p>
                <p>HeapSort è un algoritmo di ordinamento che utilizza la struttura dati Max-Heap. È un algoritmo di ordinamento basato su confronti, efficiente e in-place (se implementato con attenzione).</p>
                <p><strong>Idea Generale di HeapSort:</strong></p>
                <ol>
                    <li><strong>Costruire una Max-Heap:</strong> Dato un array di input \(A\), trasformarlo in una Max-Heap. Questa operazione è svolta da una procedura chiamata <code>Build-Max-Heap(A)</code>. Dopo questo passo, l'elemento più grande dell'array si troverà alla radice dell'heap (<code>A[1]</code>).</li>
                    <li><strong>Fase di Ordinamento:</strong>
                        <ul>
                            <li>Ripetere per \(i\) da <code>A.length</code> decrescendo fino a 2:
                                <ol>
                                    <li><strong>Scambiare</strong> l'elemento alla radice <code>A[1]</code> (che è il massimo corrente nell'heap rimanente) con l'elemento <code>A[i]</code> (l'ultima posizione corrente dell'heap). Ora l'elemento massimo per questa iterazione è nella sua posizione finale corretta nell'array ordinato (alla fine della porzione ancora da ordinare).</li>
                                    <li><strong>Ridurre la dimensione dell'heap:</strong> <code>A.heapsize ← A.heapsize - 1</code>. L'elemento <code>A[i]</code> (il massimo appena posizionato) non fa più parte dell'heap.</li>
                                    <li><strong>Ripristinare la proprietà di Max-Heap:</strong> L'elemento che è stato spostato alla radice (l'ex <code>A[i]</code>) potrebbe violare la proprietà. Chiamare <code>Max-Heapify(A, 1)</code> sull'heap ridotto per ripristinare la proprietà.</li>
                                </ol>
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Al termine, l'array \(A\) sarà ordinato in modo non decrescente.</p>
                <p>La professoressa illustra (pagina 7 OCR) l'idea: si ha un vettore A. Prima si fa `BuildHeap(A)` per trasformarlo in una Max-Heap. Poi, iterativamente, si prende l'elemento massimo (alla radice), lo si sposta all'ultima posizione dell'heap corrente, si "accorcia" l'heap (diminuendo `heapsize`) e si chiama `Heapify` sulla nuova radice.</p>
                <div class="array-representation">
                    <p>Idea di HeapSort:</p>
                    <p>1. Array Iniziale A: <code>[X, X, X, X, X, X]</code></p>
                    <p>2. Dopo Build-Max-Heap(A): <code>[MAX₁, Y, Z, ..., W]</code> (heapsize = n)</p>
                    <p>3. Iterazione 1 (i=n):</p>
                    <p>   Scambia A[1] (MAX₁) con A[n] (W): <code>[W, Y, Z, ..., MAX₁]</code></p>
                    <p>   heapsize = n-1. Ora MAX₁ è "fuori" dall'heap, nella sua posizione finale.</p>
                    <p>   Max-Heapify(A, 1) sull'heap A[1...n-1]. L'array diventa: <code>[MAX₂, Y', Z', ...] | [MAX₁]</code></p>
                    <p>4. Iterazione 2 (i=n-1):</p>
                    <p>   Scambia A[1] (MAX₂) con A[n-1]: <code>[..., Y', Z', MAX₂] | [MAX₁]</code></p>
                    <p>   heapsize = n-2. Ora MAX₂ è nella sua posizione finale.</p>
                    <p>   Max-Heapify(A, 1) sull'heap A[1...n-2].</p>
                    <p>...e così via.</p>
                </div>

                <pre><code class="language-pseudocode">
HeapSort(A)
  Build-Max-Heap(A) // Trasforma A in una Max-Heap
  for i ← A.length downto 2 do
    SWAP(A[1], A[i])
    A.heapsize ← A.heapsize - 1 
    Max-Heapify(A, 1)
                </code></pre>
                <p><strong>Nota:</strong> Nello pseudo-codice, <code>A.heapsize</code> deve essere gestito correttamente. Inizialmente, <code>A.heapsize = A.length</code> dopo <code>Build-Max-Heap</code>. All'interno del ciclo <code>for</code>, <code>Max-Heapify</code> opera sulla porzione dell'array che costituisce l'heap corrente, la cui dimensione è data da <code>A.heapsize</code> (che viene decrementata).</p>
            </div>
        </article>

        <article id="build-heap-procedura" class="content-section">
            <h3 class="subsection-title">4.1. Procedura Ausiliaria: Build-Max-Heap(A)</h3>
            <div class="section-content">
                <p>La procedura <code>Build-Max-Heap(A)</code> costruisce una Max-Heap a partire da un array \(A\) non ordinato.</p>
                <p><strong>Idea:</strong> Si utilizza la procedura <code>Max-Heapify</code>. Ricordiamo che <code>Max-Heapify(H, i)</code> funziona correttamente se i sottoalberi radicati nei figli di `i` sono già Max-Heap.</p>
                <p>Le foglie di un albero sono, per definizione, delle Max-Heap (banalmente, non hanno figli, quindi la proprietà è soddisfatta).</p>
                <p>Sappiamo che in un array che rappresenta un heap, gli elementi con indici da <code>floor(A.length / 2) + 1</code> fino a <code>A.length</code> sono foglie.</p>
                <p>Quindi, possiamo costruire l'heap "dal basso verso l'alto":</p>
                <ol>
                    <li>Imposta <code>A.heapsize ← A.length</code>.</li>
                    <li>Itera con un indice `i` a partire dall'ultimo nodo che NON è una foglia (cioè <code>floor(A.length / 2)</code>) e vai a ritroso fino alla radice (indice 1).</li>
                    <li>Per ogni tale nodo `i`, chiama <code>Max-Heapify(A, i)</code>.</li>
                </ol>
                <p>Quando <code>Max-Heapify(A, i)</code> viene chiamata, i figli di `i` (che hanno indici <code>2i</code> e <code>2i+1</code>) sono già stati processati dal ciclo (perché <code>2i > i</code> e il ciclo va a ritroso) oppure sono foglie. In entrambi i casi, i sottoalberi radicati nei figli di `i` sono già Max-Heap, soddisfacendo la precondizione di `Max-Heapify`.</p>
                <pre><code class="language-pseudocode">
Build-Max-Heap(A)
  A.heapsize ← A.length
  for i ← floor(A.length / 2) downto 1 do
    Max-Heapify(A, i)
                </code></pre>
            </div>
        </article>

        <article id="complessita-build-heap" class="content-section">
            <h3 class="subsection-title">4.2. Complessità di Build-Max-Heap (Analisi più precisa)</h3>
            <div class="section-content">
                <p>Una stima approssimativa della complessità di <code>Build-Max-Heap</code> potrebbe essere: il ciclo <code>for</code> esegue circa \(n/2\) iterazioni. Ogni chiamata a <code>Max-Heapify</code> costa \(O(\log n)\). Quindi, \( (n/2) \cdot O(\log n) = O(n \log n) \).</p>
                <p>Questa stima è corretta (è un limite superiore), ma non è stretta. Si può dimostrare che <strong><code>Build-Max-Heap</code> ha una complessità lineare, cioè \(\Theta(n)\)</strong>.</p>
                <p><strong>Analisi più stretta (Idea):</strong></p>
                <p>La maggior parte delle chiamate a <code>Max-Heapify</code> avviene su nodi che sono vicini alle foglie, e quindi hanno un'altezza piccola. Il costo di <code>Max-Heapify(A, i)</code> è \(O(h_i)\), dove \(h_i\) è l'altezza del nodo `i`.</p>
                <p>In un heap con \(n\) nodi, ci sono al più \(\lceil n / 2^{h+1} \rceil\) nodi di altezza \(h\).</p>
                <p>Il costo totale di <code>Build-Max-Heap</code> è quindi:</p>
                <div class="math-block">
                \( \sum_{h=0}^{\lfloor \log n \rfloor} \left\lceil \frac{n}{2^{h+1}} \right\rceil O(h) \)
                </div>
                <p>Questa sommatoria si può dimostrare essere \(O(n)\) (non \(\Theta(n \log n)\)).
                (La dimostrazione dettagliata coinvolge la sostituzione \(\lceil n / 2^{h+1} \rceil \le n / 2^h\) e la manipolazione della serie \(\sum_{h=0}^{\log n} h/2^h\), che converge a una costante).</p>
                <p><strong>Conclusione per Build-Max-Heap:</strong> Tempo \(\Theta(n)\).</p>
            </div>
        </article>

        <article id="complessita-heapsort" class="content-section">
            <h3 class="subsection-title">4.3. Complessità Complessiva di HeapSort</h3>
            <p>Riprendiamo l'algoritmo <code>HeapSort(A)</code>:</p>
                <pre><code class="language-pseudocode">
HeapSort(A)
  1. Build-Max-Heap(A)  // Costo Θ(n)
  2. for i ← A.length downto 2 do // Ciclo eseguito n-1 volte
  3.   SWAP(A[1], A[i])           // Costo Θ(1)
  4.   A.heapsize ← A.heapsize - 1 // Costo Θ(1)
  5.   Max-Heapify(A, 1)          // Costo O(log i) o O(log(A.heapsize))
                </code></pre>
            <p>Analisi dei costi:</p>
            <ul>
                <li><strong>Riga 1 (Build-Max-Heap):</strong> \(\Theta(n)\).</li>
                <li><strong>Ciclo for (Righe 2-5):</strong>
                    <ul>
                        <li>Le righe 3 e 4 sono \(\Theta(1)\) per ogni iterazione.</li>
                        <li>La riga 5 (<code>Max-Heapify</code>) viene chiamata su un heap la cui dimensione diminuisce ad ogni iterazione. Il costo è \(O(\log k)\) dove \(k\) è la dimensione corrente dell'heap.
                        Il ciclo va per \(i\) da \(n\) a \(2\). La dimensione dell'heap va da \(n-1\) a \(1\).</li>
                        <li>Costo totale del ciclo: \( \sum_{k=1}^{n-1} O(\log k) \).</li>
                        <li>Questa somma è \(O(n \log n)\). (Poiché \( \sum_{k=1}^{m} \log k \approx \int_1^m \log x \,dx = [x \log x - x]_1^m \approx m \log m \)).</li>
                    </ul>
                </li>
            </ul>
            <p><strong>Complessità Totale di HeapSort:</strong></p>
            <div class="math-block">
            \( T(n) = \Theta(n) + O(n \log n) = O(n \log n) \)
            </div>
            <p>Poiché HeapSort è un algoritmo di ordinamento basato su confronti e il limite inferiore per l'ordinamento basato su confronti è \(\Omega(n \log n)\), allora HeapSort è asintoticamente ottimale.</p>
            <div class="math-block">
            \( T(n) = \Theta(n \log n) \)
            </div>
            <p><strong>Spazio:</strong> HeapSort è un algoritmo <strong>in-place</strong> (spazio \(\Theta(1)\) aggiuntivo), poiché tutte le operazioni avvengono direttamente sull'array di input (se si implementa `Max-Heapify` iterativamente o se la ricorsione è ottimizzata dal compilatore per non consumare stack proporzionale a \(\log n\)).</p>
        </article>

    </main>

    <footer>
        <p>© 2023 Appunti Corso Algoritmi</p>
    </footer>

    <script src="../../assets/js/common.js"></script>
    <script>
    // Stessa logica di Mermaid.js da lezioni precedenti per il rendering degli alberi
    document.addEventListener('DOMContentLoaded', function () {
        if (typeof mermaid !== 'undefined') {
            mermaid.initialize({
                startOnLoad: false, 
                theme: 'dark',
                darkMode: true,
                fontFamily: getComputedStyle(document.documentElement).getPropertyValue('--font-code').trim(),
                 themeVariables: {
                    primaryColor: getComputedStyle(document.documentElement).getPropertyValue('--bg-card').trim(),
                    primaryTextColor: getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim(),
                    primaryBorderColor: getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim(),
                    lineColor: getComputedStyle(document.documentElement).getPropertyValue('--accent-secondary').trim(),
                    secondaryColor: getComputedStyle(document.documentElement).getPropertyValue('--bg-deep-space').trim(),
                    tertiaryColor: getComputedStyle(document.documentElement).getPropertyValue('--bg-card').trim(),
                    fontSize: '14px',
                    textColor: getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim(),
                    mainBkg: getComputedStyle(document.documentElement).getPropertyValue('--code-bg').trim(), 
                    nodeBorder: getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim(),
                }
            });

            const mermaidOriginalDefinitions = new Map();
            document.querySelectorAll('.mermaid').forEach((diag, index) => {
                const id = diag.id || `mermaid-dynamic-init-${index}`;
                diag.id = id;
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = diag.innerHTML; 
                const decodedContent = tempDiv.textContent || tempDiv.innerText || ""; 
                mermaidOriginalDefinitions.set(id, decodedContent.trim());
                diag.innerHTML = ''; 
                diag.style.visibility = 'hidden'; 
            });

            async function renderMermaidDiagram(diagElement) {
                const diagramId = diagElement.id;
                const diagramDefinition = mermaidOriginalDefinitions.get(diagramId);

                if (!diagramDefinition) {
                    // console.warn("Nessuna definizione originale per Mermaid ID:", diagramId);
                    diagElement.innerHTML = `<p style="color:var(--accent-primary); font-weight:bold;">Definizione diagramma non trovata.</p>`;
                    diagElement.style.visibility = 'visible';
                    return;
                }
                diagElement.innerHTML = ''; 
                try {
                    const tempSvgId = 'tempsvg-' + diagramId + '-' + Date.now(); 
                    const { svg } = await mermaid.render(tempSvgId, diagramDefinition);
                    diagElement.innerHTML = svg;
                    diagElement.style.visibility = 'visible';
                } catch (e) {
                    // console.error("Errore rendering Mermaid per ID:", diagramId, "\nErrore:", e, "\nDefinizione:", diagramDefinition);
                    diagElement.innerHTML = `<p style="color:var(--accent-primary); font-weight:bold;">Errore rendering Mermaid:</p><pre style="text-align:left; white-space:pre-wrap; word-wrap:break-word; color: var(--text-secondary);">${e.message}\n\n${diagramDefinition.replace(/</g, "<").replace(/>/g, ">")}</pre>`;
                    diagElement.style.visibility = 'visible';
                }
            }
            
            document.querySelectorAll('.content-section').forEach(section => {
                section.addEventListener('sectionshown', function(event) {
                    this.querySelectorAll('.mermaid').forEach(renderMermaidDiagram);
                });
            });
            
            const initiallyActiveSection = document.querySelector('.content-section.active-section');
            if (initiallyActiveSection) {
                initiallyActiveSection.querySelectorAll('.mermaid').forEach(renderMermaidDiagram);
            }
        }
    });
    </script>
</body>
</html>